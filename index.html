<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë©”ë¡  ê²Œì„ - ì›¹ ë²„ì „</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        
        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
        }
        
        .game-title {
            font-size: 2.5em;
            font-weight: bold;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .game-subtitle {
            font-size: 1.2em;
            margin: 10px 0;
            opacity: 0.9;
        }
        
        #gameCanvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            display: block;
            background: #2c3e50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            color: white;
            font-size: 1.1em;
        }
        
        .score-display {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 0.9em;
        }
        
        .loading {
            text-align: center;
            color: white;
            font-size: 1.5em;
            padding: 50px;
        }
        
        .error {
            text-align: center;
            color: #ff6b6b;
            font-size: 1.3em;
            padding: 50px;
            background: rgba(255, 0, 0, 0.1);
            border-radius: 10px;
            margin: 20px;
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            color: white;
            font-size: 0.9em;
            line-height: 1.6;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: #ffd93d;
        }
        
        .instructions ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .instructions li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">ğŸˆ ë©”ë¡  ê²Œì„ ğŸˆ</h1>
            <p class="game-subtitle">ê°™ì€ ê³¼ì¼ì„ í•©ì³ì„œ ë” í° ê³¼ì¼ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”!</p>
        </div>
        
        <div class="instructions">
            <h3>ğŸ® ê²Œì„ ë°©ë²•</h3>
            <ul>
                <li><strong>ë§ˆìš°ìŠ¤ í´ë¦­:</strong> ê³¼ì¼ ë–¨ì–´ëœ¨ë¦¬ê¸°</li>
                <li><strong>ë§ˆìš°ìŠ¤ ì›€ì§ì„:</strong> ê³¼ì¼ ë–¨ì–´ëœ¨ë¦´ ìœ„ì¹˜ ì¡°ì ˆ</li>
                <li><strong>ê°™ì€ ê³¼ì¼ í•©ì¹˜ê¸°:</strong> ê°™ì€ ì¢…ë¥˜ì˜ ê³¼ì¼ì´ ë‹¿ìœ¼ë©´ ë” í° ê³¼ì¼ë¡œ í•©ì³ì ¸ìš”</li>
                <li><strong>í­íƒ„ ì¡°ì‹¬:</strong> í­íƒ„ì´ í„°ì§€ë©´ ì£¼ë³€ ê³¼ì¼ë“¤ì´ ì‚¬ë¼ì ¸ìš”</li>
                <li><strong>ìŠ¤ìœ„ì¹˜ ëª¨ë“œ:</strong> í­íƒ„ íƒ€ì´ë¨¸ê°€ ì¤„ì–´ë“¤ë©´ ìŠ¤ìœ„ì¹˜ ëª¨ë“œê°€ í™œì„±í™”ë¼ìš”</li>
                <li><strong>ëª©í‘œ:</strong> ê°€ì¥ í° ë©”ë¡  ê³¼ì¼ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”!</li>
            </ul>
        </div>
        
        <div id="loading" class="loading">
            ê²Œì„ ë¡œë”© ì¤‘... ğŸ“ğŸ‡ğŸŠ
        </div>
        
        <div id="error" class="error" style="display: none;">
            ê²Œì„ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.
        </div>
        
        <canvas id="gameCanvas" style="display: none;"></canvas>
        
        <div class="game-info">
            <div class="score-display">
                ì ìˆ˜: <span id="score">0</span>
            </div>
            <div class="controls">
                ë§ˆìš°ìŠ¤ë¡œ ì¡°ì‘í•˜ì„¸ìš”
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <script>
        // ê²Œì„ ì„¤ì •
        const gameConfig = {
            type: Phaser.AUTO,
            width: 400,
            height: 600,
            parent: 'gameCanvas',
            backgroundColor: '#2c3e50',
            physics: {
                default: 'matter',
                matter: {
                    gravity: { y: 1 },
                    enableSleep: false,
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        // ê²Œì„ ë³€ìˆ˜
        let game;
        let score = 0;
        let fruits = [];
        let previewFruit;
        let canDrop = true;
        let dropCooldown = 0;
        let isSwitchMode = false;
        let switchTimer = 0;
        let bombTimer = 0;

        // ê³¼ì¼ ì„¤ì •
        const fruitTypes = [
            { emoji: 'ğŸ’', size: 20, points: 1, color: '#ff6b6b' },
            { emoji: 'ğŸ“', size: 25, points: 2, color: '#ff8787' },
            { emoji: 'ğŸ‡', size: 30, points: 4, color: '#9b59b6' },
            { emoji: 'ğŸŠ', size: 35, points: 8, color: '#f39c12' },
            { emoji: 'ğŸ‹', size: 40, points: 16, color: '#f1c40f' },
            { emoji: 'ğŸ', size: 45, points: 32, color: '#e74c3c' },
            { emoji: 'ğŸ‘', size: 50, points: 64, color: '#ffb6c1' },
            { emoji: 'ğŸ¥', size: 55, points: 128, color: '#27ae60' },
            { emoji: 'ğŸˆ', size: 60, points: 256, color: '#2ecc71' },
            { emoji: 'ğŸ’£', size: 35, points: 0, color: '#000000', isBomb: true }
        ];

        function preload() {
            // ê²Œì„ ë¦¬ì†ŒìŠ¤ ë¡œë”©
            console.log('ê²Œì„ ë¦¬ì†ŒìŠ¤ ë¡œë”© ì¤‘...');
        }

        function create() {
            // ê²Œì„ ì´ˆê¸° ì„¤ì •
            this.matter.world.setBounds(0, 0, 400, 600);
            
            // ë°”ë‹¥ ìƒì„±
            this.matter.add.rectangle(200, 595, 400, 10, { 
                isStatic: true,
                label: 'ground'
            });
            
            // ë²½ ìƒì„±
            this.matter.add.rectangle(5, 300, 10, 600, { 
                isStatic: true,
                label: 'wall-left'
            });
            this.matter.add.rectangle(395, 300, 10, 600, { 
                isStatic: true,
                label: 'wall-right'
            });
            
            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
            this.input.on('pointerdown', handlePointerDown);
            this.input.on('pointermove', handlePointerMove);
            
            // ì ìˆ˜ í‘œì‹œ ì´ˆê¸°í™”
            updateScore();
            
            // ë¡œë”© ìˆ¨ê¸°ê³  ê²Œì„ ìº”ë²„ìŠ¤ í‘œì‹œ
            document.getElementById('loading').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            
            console.log('ê²Œì„ ì‹œì‘!');
        }

        function update() {
            // ë“œë¡­ ì¿¨ë‹¤ìš´ ì²˜ë¦¬
            if (dropCooldown > 0) {
                dropCooldown--;
                if (dropCooldown === 0) {
                    canDrop = true;
                }
            }
            
            // ìŠ¤ìœ„ì¹˜ ëª¨ë“œ íƒ€ì´ë¨¸ ì²˜ë¦¬
            if (isSwitchMode) {
                switchTimer++;
                if (switchTimer > 300) { // 5ì´ˆ í›„
                    isSwitchMode = false;
                    switchTimer = 0;
                }
            }
            
            // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
            updatePreview();
        }

        function handlePointerDown(pointer) {
            if (!canDrop) return;
            
            const fruitType = isSwitchMode ? 
                fruitTypes[fruitTypes.length - 1] : // í­íƒ„
                fruitTypes[Math.floor(Math.random() * (fruitTypes.length - 1))]; // ì¼ë°˜ ê³¼ì¼
            
            dropFruit(pointer.x, 100, fruitType);
            
            canDrop = false;
            dropCooldown = 30; // 0.5ì´ˆ ì¿¨ë‹¤ìš´
        }

        function handlePointerMove(pointer) {
            // ë¯¸ë¦¬ë³´ê¸° ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updatePreview();
        }

        function dropFruit(x, y, fruitType) {
            const fruit = this.matter.add.circle(x, y, fruitType.size / 2, {
                restitution: 0.3,
                friction: 0.1,
                density: 0.001,
                label: fruitType.emoji,
                fruitType: fruitType
            });
            
            // ê³¼ì¼ ì´ëª¨ì§€ ì¶”ê°€
            const text = this.add.text(x, y, fruitType.emoji, {
                fontSize: fruitType.size + 'px',
                fontFamily: 'Arial'
            }).setOrigin(0.5);
            
            // ê³¼ì¼ ì •ë³´ ì €ì¥
            fruit.text = text;
            fruit.fruitType = fruitType;
            
            fruits.push(fruit);
            
            // ì¶©ëŒ ì´ë²¤íŠ¸
            this.matter.world.on('collisionstart', (event) => {
                event.pairs.forEach(pair => {
                    if (pair.bodyA === fruit || pair.bodyB === fruit) {
                        checkCollision(pair);
                    }
                });
            });
        }

        function checkCollision(pair) {
            const bodyA = pair.bodyA;
            const bodyB = pair.bodyB;
            
            if (!bodyA.fruitType || !bodyB.fruitType) return;
            
            // í­íƒ„ ì¶©ëŒ ì²˜ë¦¬
            if (bodyA.fruitType.isBomb || bodyB.fruitType.isBomb) {
                handleBombCollision(bodyA, bodyB);
                return;
            }
            
            // ê°™ì€ ê³¼ì¼ í•©ì¹˜ê¸°
            if (bodyA.fruitType.emoji === bodyB.fruitType.emoji) {
                mergeFruits(bodyA, bodyB);
            }
        }

        function handleBombCollision(bomb, other) {
            // í­íƒ„ í„°ëœ¨ë¦¬ê¸°
            createExplosion(bomb.position.x, bomb.position.y);
            
            // ì£¼ë³€ ê³¼ì¼ë“¤ ì œê±°
            fruits.forEach(fruit => {
                const distance = Math.sqrt(
                    Math.pow(fruit.position.x - bomb.position.x, 2) + 
                    Math.pow(fruit.position.y - bomb.position.y, 2)
                );
                
                if (distance < 100) {
                    if (fruit.text) fruit.text.destroy();
                    this.matter.world.remove(fruit);
                }
            });
            
            // í­íƒ„ ì œê±°
            if (bomb.text) bomb.text.destroy();
            this.matter.world.remove(bomb);
            
            // ìŠ¤ìœ„ì¹˜ ëª¨ë“œ í™œì„±í™”
            isSwitchMode = true;
            switchTimer = 0;
        }

        function createExplosion(x, y) {
            // í­ë°œ íš¨ê³¼
            for (let i = 0; i < 10; i++) {
                const particle = this.add.circle(x, y, 5, 0xff6b6b);
                particle.setAlpha(1);
                
                this.tweens.add({
                    targets: particle,
                    x: x + (Math.random() - 0.5) * 100,
                    y: y + (Math.random() - 0.5) * 100,
                    alpha: 0,
                    scale: 2,
                    duration: 500,
                    onComplete: () => particle.destroy()
                });
            }
        }

        function mergeFruits(fruit1, fruit2) {
            const currentIndex = fruitTypes.findIndex(f => f.emoji === fruit1.fruitType.emoji);
            const nextIndex = currentIndex + 1;
            
            if (nextIndex >= fruitTypes.length - 1) return; // ë§ˆì§€ë§‰ ê³¼ì¼ì€ í•©ì¹  ìˆ˜ ì—†ìŒ
            
            const newFruitType = fruitTypes[nextIndex];
            const centerX = (fruit1.position.x + fruit2.position.x) / 2;
            const centerY = (fruit1.position.y + fruit2.position.y) / 2;
            
            // ì ìˆ˜ ì¶”ê°€
            score += newFruitType.points;
            updateScore();
            
            // ìƒˆ ê³¼ì¼ ìƒì„±
            const newFruit = this.matter.add.circle(centerX, centerY, newFruitType.size / 2, {
                restitution: 0.3,
                friction: 0.1,
                density: 0.001,
                label: newFruitType.emoji,
                fruitType: newFruitType
            });
            
            const newText = this.add.text(centerX, centerY, newFruitType.emoji, {
                fontSize: newFruitType.size + 'px',
                fontFamily: 'Arial'
            }).setOrigin(0.5);
            
            newFruit.text = newText;
            newFruit.fruitType = newFruitType;
            
            // ê¸°ì¡´ ê³¼ì¼ë“¤ ì œê±°
            if (fruit1.text) fruit1.text.destroy();
            if (fruit2.text) fruit2.text.destroy();
            this.matter.world.remove(fruit1);
            this.matter.world.remove(fruit2);
            
            // ë°°ì—´ ì—…ë°ì´íŠ¸
            fruits = fruits.filter(f => f !== fruit1 && f !== fruit2);
            fruits.push(newFruit);
            
            // í•©ì¹˜ê¸° íš¨ê³¼
            createMergeEffect(centerX, centerY);
        }

        function createMergeEffect(x, y) {
            const effect = this.add.circle(x, y, 20, 0xffffff);
            effect.setAlpha(0.5);
            
            this.tweens.add({
                targets: effect,
                scale: 3,
                alpha: 0,
                duration: 300,
                onComplete: () => effect.destroy()
            });
        }

        function updatePreview() {
            // ë¯¸ë¦¬ë³´ê¸° ë¡œì§ (ê°„ë‹¨í•œ ë²„ì „)
            if (this.previewText) {
                this.previewText.destroy();
            }
            
            const pointer = this.input.activePointer;
            const fruitType = isSwitchMode ? 
                fruitTypes[fruitTypes.length - 1] : 
                fruitTypes[Math.floor(Math.random() * (fruitTypes.length - 1))];
            
            this.previewText = this.add.text(pointer.x, 100, fruitType.emoji, {
                fontSize: fruitType.size + 'px',
                fontFamily: 'Arial',
                alpha: 0.5
            }).setOrigin(0.5);
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        // ê²Œì„ ì‹œì‘
        window.addEventListener('load', () => {
            try {
                game = new Phaser.Game(gameConfig);
            } catch (error) {
                console.error('ê²Œì„ ë¡œë”© ì˜¤ë¥˜:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
            }
        });
    </script>
</body>
</html>

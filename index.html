<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>과일 합치기 게임</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="game-container">
        <div id="score-container">점수: <span id="score">0</span></div>
        <div id="drop-line"></div>
        <div id="waiting-fruit"></div>
        <div id="special-item">무게추 (3/3)</div>
        <div id="cooldown-overlay"></div>
        <div id="game-over">
            <div id="game-over-content">
                <h2>게임 오버</h2>
                <p>최종 점수: <span id="final-score">0</span></p>
                <button id="restart-button">다시 시작</button>
            </div>
        </div>
        <canvas id="game-canvas"></canvas>
    </div>

    <script src="variables.js"></script>
    <script src="fruit.js"></script>

    <script>
        // 게임 시작
        window.onload = function() {
            initGame();
            
            // 과일 라벨 업데이트 간격 설정
            setInterval(() => {
                updateFruitLabels(); // 라벨 업데이트
                checkFruitMerging(); // 과일 합치기 검사
            }, 1000 / 60); // 약 60fps
            
            // 게임오버 체크 간격 설정
            setInterval(() => {
                checkGameOver();
            }, 1000);
        };
        
        // 벽 생성
        function createWalls() {
            // 바닥
            const floor = Bodies.rectangle(containerWidth / 2, containerHeight, containerWidth, 50, { 
                isStatic: true,
                friction: 0.1
            });
            
            // 왼쪽 벽
            const leftWall = Bodies.rectangle(0, containerHeight / 2, 50, containerHeight, { 
                isStatic: true,
                friction: 0.1
            });
            
            // 오른쪽 벽
            const rightWall = Bodies.rectangle(containerWidth, containerHeight / 2, 50, containerHeight, { 
                isStatic: true,
                friction: 0.1
            });
            
            walls = [floor, leftWall, rightWall];
            World.add(engine.world, walls);
        }

        // 특수 무게추 생성
        function createSpecialWeight(x, y) {
            const body = Bodies.rectangle(x, y, SPECIAL_WEIGHT.width, SPECIAL_WEIGHT.height, {
                restitution: 0.2,
                friction: 0.1,
                frictionAir: 0.03,
                frictionStatic: 0.5,
                density: SPECIAL_WEIGHT.weight
            });
            
            body.isWeight = true;
            
            // 초기 속도 설정
            Body.setVelocity(body, { x: 0, y: SPECIAL_WEIGHT.initialVelocity });
            
            World.add(engine.world, body);
            weights.push(body);
            
            return body;
        }

        // 충돌 이벤트 설정
        function setupCollisionEvents() {
            Events.on(engine, 'collisionStart', (event) => {
                const pairs = event.pairs;
                
                for (let i = 0; i < pairs.length; i++) {
                    const pair = pairs[i];
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;
                    
                    // 충돌 힘 계산
                    const collisionForce = Math.abs(bodyA.force.x) + Math.abs(bodyA.force.y) + Math.abs(bodyB.force.x) + Math.abs(bodyB.force.y);
                    
                    // 충돌 힘 임계값보다 작은 충돌은 무시
                    if (collisionForce < MIN_COLLISION_FORCE) {
                        continue;
                    }
                    
                    // 과일끼리 충돌
                    if (bodyA.isFruit && bodyB.isFruit) {
                        // 같은 종류의 과일이고 합이 10인 경우
                        if (bodyA.fruitIndex === bodyB.fruitIndex && 
                            bodyA.fruitNumber + bodyB.fruitNumber === 10 && 
                            bodyA.fruitIndex < FRUITS.length - 1 && 
                            !bodyA.cooldown && !bodyB.cooldown) {
                            
                            // 중간 위치 계산
                            const midX = (bodyA.position.x + bodyB.position.x) / 2;
                            const midY = (bodyA.position.y + bodyB.position.y) / 2;
                            
                            // 기존 과일 라벨 제거
                            removeFruitLabel(bodyA);
                            removeFruitLabel(bodyB);
                            
                            // 기존 과일 제거
                            removeBody(bodyA);
                            removeBody(bodyB);
                            
                            // 다음 단계 과일 생성
                            const newFruitIndex = bodyA.fruitIndex + 1;
                            
                            // 랜덤 숫자 생성 (기존 확률 분포 사용)
                            let randomNumber;
                            const rand = Math.random();
                            
                            if (rand < 0.50) { // 50% 확률로 1-3 사이
                                randomNumber = Math.floor(Math.random() * 3) + 1;
                            } else if (rand < 0.80) { // 30% 확률로 4-5 사이
                                randomNumber = Math.floor(Math.random() * 2) + 4;
                            } else if (rand < 0.95) { // 15% 확률로 6-7 사이
                                randomNumber = Math.floor(Math.random() * 2) + 6;
                            } else { // 5% 확률로 8-9 사이
                                randomNumber = Math.floor(Math.random() * 2) + 8;
                            }
                            
                            // 새 과일 생성
                            const newFruit = createFruit(midX, midY, newFruitIndex);
                            
                            // 생성된 과일에 랜덤 숫자 할당
                            newFruit.fruitNumber = randomNumber;
                            
                            // 기존 과일 라벨 제거 후 새로 생성
                            removeFruitLabel(newFruit);
                            createFruitLabel(newFruit, randomNumber);
                            
                            // 쿨타임 설정 - 0.5초 동안 합치기 불가능
                            newFruit.cooldown = true;
                            setTimeout(() => {
                                newFruit.cooldown = false;
                            }, 500);
                            
                            // 점수 추가
                            score += FRUITS[newFruitIndex].score;
                            document.getElementById('score').textContent = score;
                        }
                    }
                    
                    // 무게추와 과일 충돌
                    if ((bodyA.isWeight && bodyB.isFruit) || (bodyA.isFruit && bodyB.isWeight)) {
                        const fruit = bodyA.isFruit ? bodyA : bodyB;
                        
                        // 과일에 추가 힘 적용
                        const forceMagnitude = 0.01 * fruit.mass;
                        Body.applyForce(fruit, fruit.position, {
                            x: (Math.random() - 0.5) * forceMagnitude,
                            y: -forceMagnitude
                        });
                    }
                }
            });
        }

        // 바디 제거
        function removeBody(body) {
            World.remove(engine.world, body);
            
            if (body.isFruit) {
                const index = fruits.indexOf(body);
                if (index > -1) {
                    fruits.splice(index, 1);
                }
            } else if (body.isWeight) {
                const index = weights.indexOf(body);
                if (index > -1) {
                    weights.splice(index, 1);
                }
            }
        }

        // 특수 무게추 드롭
        function dropSpecialWeight(x, y) {
            if (!SPECIAL_WEIGHT.available || SPECIAL_WEIGHT.remainingUses <= 0) return;
            
            createSpecialWeight(x, y);
            
            SPECIAL_WEIGHT.remainingUses--;
            specialItemUI.textContent = `무게추 (${SPECIAL_WEIGHT.remainingUses}/${SPECIAL_WEIGHT.maxUses})`;
            
            if (SPECIAL_WEIGHT.remainingUses === 0) {
                specialItemUI.style.opacity = '0.5';
            }
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 마우스 이동
            container.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                
                if (canDropFruit) {
                    const fruit = FRUITS[nextFruitIndex];
                    waitingFruitElement.style.left = `${mouseX - fruit.circleRadius}px`;
                }
                
                if (isDraggingWeight) {
                    specialItemUI.style.left = `${e.clientX - rect.left - 40}px`;
                    specialItemUI.style.top = `${e.clientY - rect.top - 40}px`;
                }
            });
            
            // 클릭
            container.addEventListener('click', (e) => {
                if (!isDraggingWeight) {
                    dropFruit();
                }
            });
            
            // 무게추 드래그 시작
            let originalWeightPosition = { top: '20px', right: '20px' };
            
            specialItemUI.addEventListener('mousedown', (e) => {
                if (SPECIAL_WEIGHT.available && SPECIAL_WEIGHT.remainingUses > 0) {
                    isDraggingWeight = true;
                    originalWeightPosition = {
                        top: specialItemUI.style.top,
                        right: specialItemUI.style.right
                    };
                    
                    specialItemUI.style.right = 'auto';
                    specialItemUI.style.cursor = 'grabbing';
                    
                    const rect = container.getBoundingClientRect();
                    specialItemUI.style.left = `${e.clientX - rect.left - 40}px`;
                    specialItemUI.style.top = `${e.clientY - rect.top - 40}px`;
                    
                    e.preventDefault();
                }
            });
            
            // 무게추 드래그 종료
            document.addEventListener('mouseup', (e) => {
                if (isDraggingWeight) {
                    isDraggingWeight = false;
                    
                    specialItemUI.style.cursor = 'grab';
                    
                    const rect = container.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if (x >= 0 && x <= containerWidth && y >= 120 && y <= containerHeight) {
                        dropSpecialWeight(x, y);
                        
                        specialItemUI.style.left = 'auto';
                        specialItemUI.style.top = originalWeightPosition.top;
                        specialItemUI.style.right = originalWeightPosition.right;
                    } else {
                        specialItemUI.style.left = 'auto';
                        specialItemUI.style.top = originalWeightPosition.top;
                        specialItemUI.style.right = originalWeightPosition.right;
                    }
                }
            });
            
            // 게임 재시작 버튼
            document.getElementById('restart-button').addEventListener('click', () => {
                resetGame();
            });
        }

        // 게임오버 체크
        function checkGameOver() {
            if (isGameOver) return;
            
            const lineY = 120;
            
            for (let i = 0; i < fruits.length; i++) {
                const fruit = fruits[i];
                
                const isSleeping = fruit.speed < 0.1;
                const isAboveLine = fruit.position.y < lineY;
                
                if (isSleeping && isAboveLine) {
                    gameOver();
                    return;
                }
            }
        }

        // 게임 오버
        function gameOver() {
            isGameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'flex';
            
            Runner.stop(runner);
        }

        // 게임 리셋
        function resetGame() {
            document.getElementById('game-over').style.display = 'none';
            
            score = 0;
            document.getElementById('score').textContent = score;
            isGameOver = false;
            nextFruitIndex = 0;
            canDropFruit = true;
            fruits = [];
            weights = [];
            SPECIAL_WEIGHT.remainingUses = SPECIAL_WEIGHT.maxUses;
            specialItemUI.textContent = `무게추 (${SPECIAL_WEIGHT.remainingUses}/${SPECIAL_WEIGHT.maxUses})`;
            specialItemUI.style.opacity = '1';
            
            if (runner.enabled) {
                Runner.stop(runner);
            }
            
            World.clear(engine.world);
            Engine.clear(engine);
            
            createWalls();
            setupEventListeners();
            setupCollisionEvents();
            updateWaitingFruit();
            
            Runner.run(runner, engine);
        }

        // 게임 초기화
        function initGame() {
            score = 0;
            document.getElementById('score').textContent = score;
            isGameOver = false;
            nextFruitIndex = 0;
            canDropFruit = true;
            fruits = [];
            weights = [];
            SPECIAL_WEIGHT.remainingUses = SPECIAL_WEIGHT.maxUses;
            specialItemUI.textContent = `무게추 (${SPECIAL_WEIGHT.remainingUses}/${SPECIAL_WEIGHT.maxUses})`;
            specialItemUI.style.opacity = '1';
            
            createWalls();
            setupEventListeners();
            setupCollisionEvents();
            updateWaitingFruit();
            
            Runner.run(runner, engine);
            render();
        }

        // 과일들이 서로 접촉 중인지 확인
        function areFruitsInContact(fruits) {
            if (fruits.length <= 1) return true;
            
            // 모든 과일이 직접 접촉하는지 확인 (그래프 연결 확인)
            const n = fruits.length;
            const connected = Array(n).fill().map(() => Array(n).fill(false));
            
            // 각 과일 쌍에 대해 접촉 여부 확인
            for (let i = 0; i < n; i++) {
                connected[i][i] = true; // 자기 자신과는 연결됨
                
                for (let j = i + 1; j < n; j++) {
                    const dx = fruits[i].position.x - fruits[j].position.x;
                    const dy = fruits[i].position.y - fruits[j].position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const fruitA = FRUITS[fruits[i].fruitIndex];
                    const fruitB = FRUITS[fruits[j].fruitIndex];
                    const minDistance = fruitA.circleRadius + fruitB.circleRadius;
                    
                    // 접촉 여부 확인 (여유 공간 추가)
                    if (distance <= minDistance + 5) {
                        connected[i][j] = connected[j][i] = true;
                    }
                }
            }
            
            // 모든 과일이 하나의 연결된 그룹을 형성하는지 확인 (BFS 사용)
            const visited = Array(n).fill(false);
            const queue = [0]; // 첫 번째 과일부터 시작
            visited[0] = true;
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                for (let i = 0; i < n; i++) {
                    if (connected[current][i] && !visited[i]) {
                        visited[i] = true;
                        queue.push(i);
                    }
                }
            }
            
            // 모든 과일이 방문되었는지 확인
            return visited.every(v => v);
        }

        // 게임 렌더링
        function render() {
            // 캔버스 지우기
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 벽 그리기
            ctx.fillStyle = '#cccccc';
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                const vertices = wall.vertices;
                
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                
                for (let j = 1; j < vertices.length; j++) {
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
                
                ctx.closePath();
                ctx.fill();
            }
            
            // 과일 그리기
            for (let i = 0; i < engine.world.bodies.length; i++) {
                const body = engine.world.bodies[i];
                if (body.label === 'fruit') {
                    const fruitData = FRUITS[body.fruitIndex];
                    
                    // 과일 원 그리기
                    ctx.beginPath();
                    ctx.arc(body.position.x, body.position.y, fruitData.circleRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = fruitData.color;
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // 참고: 숫자는 HTML 라벨로 표시하므로 여기서는 그리지 않음
                }
            }
            
            // 무게추 그리기
            ctx.fillStyle = SPECIAL_WEIGHT.color;
            for (let i = 0; i < weights.length; i++) {
                const weight = weights[i];
                const vertices = weight.vertices;
                
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                
                for (let j = 1; j < vertices.length; j++) {
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            requestAnimationFrame(render);
        }
    </script>
</body>
</html>

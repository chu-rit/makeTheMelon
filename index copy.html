<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>과일 합치기 게임</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="game-container">
        <div id="score-container">점수: <span id="score">0</span></div>
        <div id="drop-line"></div>
        <div id="waiting-fruit"></div>
        <div id="special-item">무게추 (3/3)</div>
        <div id="cooldown-overlay"></div>
        <div id="game-over">
            <div id="game-over-content">
                <h2>게임 오버</h2>
                <p>최종 점수: <span id="final-score">0</span></p>
                <button id="restart-button">다시 시작</button>
            </div>
        </div>
        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        // Matter.js 모듈
        const { Engine, World, Bodies, Body, Events, Composite, Runner } = Matter;

        // 게임 상수
        const FRUITS = [
            { circleRadius: 25, color: '#FF5733', density: 0.001, score: 1, number: 1, name: '체리' },
            { circleRadius: 30, color: '#FFC300', density: 0.001, score: 2, number: 2, name: '딸기' },
            { circleRadius: 35, color: '#DAF7A6', density: 0.001, score: 4, number: 3, name: '포도' },
            { circleRadius: 40, color: '#C70039', density: 0.001, score: 8, number: 4, name: '오렌지' },
            { circleRadius: 45, color: '#900C3F', density: 0.001, score: 16, number: 5, name: '감귤' },
            { circleRadius: 50, color: '#581845', density: 0.001, score: 32, number: 6, name: '사과' },
            { circleRadius: 55, color: '#2471A3', density: 0.001, score: 64, number: 7, name: '배' },
            { circleRadius: 60, color: '#138D75', density: 0.001, score: 128, number: 8, name: '복숭아' },
            { circleRadius: 65, color: '#D4AC0D', density: 0.001, score: 256, number: 9, name: '파인애플' },
            { circleRadius: 70, color: '#D35400', density: 0.001, score: 512, number: 10, name: '멜론' },
            { circleRadius: 75, color: '#A569BD', density: 0.001, score: 1024, number: 11, name: '수박' }
        ];

        // 특수 아이템 설정
        const SPECIAL_WEIGHT = {
            width: 100,
            height: 100,
            color: '#555555',
            weight: 0.5,
            maxUses: 3, // 최대 사용 횟수
            remainingUses: 3, // 남은 사용 횟수
            available: true,
            initialVelocity: 15
        };

        // 게임 변수
        const container = document.getElementById('game-container');
        const containerWidth = 400;
        const containerHeight = 600;
        const waitingFruitElement = document.getElementById('waiting-fruit');
        const specialItemUI = document.getElementById('special-item');
        const cooldownOverlay = document.getElementById('cooldown-overlay');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        let score = 0;
        let nextFruitIndex = 0;
        let canDropFruit = true;
        let isGameOver = false;
        let mouseX = containerWidth / 2;
        let fruits = [];
        let walls = [];
        let weights = [];
        let isDraggingWeight = false;
        let fruitLabels = {};
        let nextFruitNumber = 0;

        // 캔버스 설정
        canvas.width = containerWidth;
        canvas.height = containerHeight;

        // 엔진 생성
        const engine = Engine.create({
            positionIterations: 8,
            velocityIterations: 8
        });
        
        // 중력 설정 (낮은 값으로 조정)
        engine.gravity.y = 0.5;
        
        // 충돌 처리 설정 - 작은 충돌은 무시
        const MIN_COLLISION_FORCE = 0.1; // 최소 충돌 힘 임계값
        
        // 러너 생성
        const runner = Runner.create();
        
        // 시간 스케일 설정 (낮은 값으로 조정)
        engine.timing.timeScale = 0.8;

        // 벽 생성
        function createWalls() {
            // 바닥
            const floor = Bodies.rectangle(containerWidth / 2, containerHeight, containerWidth, 50, { 
                isStatic: true,
                friction: 0.1
            });
            
            // 왼쪽 벽
            const leftWall = Bodies.rectangle(0, containerHeight / 2, 50, containerHeight, { 
                isStatic: true,
                friction: 0.1
            });
            
            // 오른쪽 벽
            const rightWall = Bodies.rectangle(containerWidth, containerHeight / 2, 50, containerHeight, { 
                isStatic: true,
                friction: 0.1
            });
            
            walls = [floor, leftWall, rightWall];
            World.add(engine.world, walls);
        }

        // 과일 생성
        function createFruit(x, y, fruitIndex) {
            const fruit = FRUITS[fruitIndex];
            
            const body = Bodies.circle(x, y, fruit.circleRadius, {
                restitution: 0.2,
                friction: 0.01,
                frictionAir: 0.03,
                frictionStatic: 0.5,
                density: fruit.density,
                render: {
                    fillStyle: fruit.color,
                    strokeStyle: '#000000',
                    lineWidth: 1
                }
            });
            
            body.label = 'fruit';
            body.isFruit = true;
            body.fruitIndex = fruitIndex;
            body.fruitNumber = nextFruitNumber; // 과일에 숫자 할당
            body.id = Date.now() + Math.random(); // 고유 ID 생성
            
            World.add(engine.world, body);
            
            // 과일 라벨 생성
            createFruitLabel(body, nextFruitNumber);
            
            // 과일을 fruits 배열에 추가
            fruits.push(body);
            
            return body;
        }

        // 특수 무게추 생성
        function createSpecialWeight(x, y) {
            const body = Bodies.rectangle(x, y, SPECIAL_WEIGHT.width, SPECIAL_WEIGHT.height, {
                restitution: 0.2,
                friction: 0.1,
                frictionAir: 0.03,
                frictionStatic: 0.5,
                density: SPECIAL_WEIGHT.weight
            });
            
            body.isWeight = true;
            
            // 초기 속도 설정
            Body.setVelocity(body, { x: 0, y: SPECIAL_WEIGHT.initialVelocity });
            
            World.add(engine.world, body);
            weights.push(body);
            
            return body;
        }

        // 충돌 이벤트 설정
        function setupCollisionEvents() {
            Events.on(engine, 'collisionStart', (event) => {
                const pairs = event.pairs;
                
                for (let i = 0; i < pairs.length; i++) {
                    const pair = pairs[i];
                    const bodyA = pair.bodyA;
                    const bodyB = pair.bodyB;
                    
                    // 충돌 힘 계산
                    const collisionForce = Math.abs(bodyA.force.x) + Math.abs(bodyA.force.y) + Math.abs(bodyB.force.x) + Math.abs(bodyB.force.y);
                    
                    // 충돌 힘 임계값보다 작은 충돌은 무시
                    if (collisionForce < MIN_COLLISION_FORCE) {
                        continue;
                    }
                    
                    // 과일끼리 충돌
                    if (bodyA.isFruit && bodyB.isFruit) {
                        // 같은 종류의 과일이고 합이 10인 경우
                        if (bodyA.fruitIndex === bodyB.fruitIndex && 
                            bodyA.fruitNumber + bodyB.fruitNumber === 10 && 
                            bodyA.fruitIndex < FRUITS.length - 1 && 
                            !bodyA.cooldown && !bodyB.cooldown) {
                            
                            // 중간 위치 계산
                            const midX = (bodyA.position.x + bodyB.position.x) / 2;
                            const midY = (bodyA.position.y + bodyB.position.y) / 2;
                            
                            // 기존 과일 라벨 제거
                            removeFruitLabel(bodyA);
                            removeFruitLabel(bodyB);
                            
                            // 기존 과일 제거
                            removeBody(bodyA);
                            removeBody(bodyB);
                            
                            // 다음 단계 과일 생성
                            const newFruitIndex = bodyA.fruitIndex + 1;
                            
                            // 랜덤 숫자 생성 (기존 확률 분포 사용)
                            let randomNumber;
                            const rand = Math.random();
                            
                            if (rand < 0.50) { // 50% 확률로 1-3 사이
                                randomNumber = Math.floor(Math.random() * 3) + 1;
                            } else if (rand < 0.80) { // 30% 확률로 4-5 사이
                                randomNumber = Math.floor(Math.random() * 2) + 4;
                            } else if (rand < 0.95) { // 15% 확률로 6-7 사이
                                randomNumber = Math.floor(Math.random() * 2) + 6;
                            } else { // 5% 확률로 8-9 사이
                                randomNumber = Math.floor(Math.random() * 2) + 8;
                            }
                            
                            // 새 과일 생성
                            const newFruit = createFruit(midX, midY, newFruitIndex);
                            
                            // 생성된 과일에 랜덤 숫자 할당
                            newFruit.fruitNumber = randomNumber;
                            
                            // 기존 과일 라벨 제거 후 새로 생성
                            removeFruitLabel(newFruit);
                            createFruitLabel(newFruit, randomNumber);
                            
                            // 쿨타임 설정 - 0.5초 동안 합치기 불가능
                            newFruit.cooldown = true;
                            setTimeout(() => {
                                newFruit.cooldown = false;
                            }, 500);
                            
                            // 점수 추가
                            score += FRUITS[newFruitIndex].score;
                            document.getElementById('score').textContent = score;
                        }
                    }
                    
                    // 무게추와 과일 충돌
                    if ((bodyA.isWeight && bodyB.isFruit) || (bodyA.isFruit && bodyB.isWeight)) {
                        const fruit = bodyA.isFruit ? bodyA : bodyB;
                        
                        // 과일에 추가 힘 적용
                        const forceMagnitude = 0.01 * fruit.mass;
                        Body.applyForce(fruit, fruit.position, {
                            x: (Math.random() - 0.5) * forceMagnitude,
                            y: -forceMagnitude
                        });
                    }
                }
            });
        }

        // 과일 합치기 검사 함수 추가
        function checkFruitMerging() {
            // 과일을 종류별로 그룹화
            const fruitGroups = {};
            
            for (const fruit of fruits) {
                // 쿨타임 중인 과일은 건너뛰기
                if (fruit.cooldown) continue;
                
                const index = fruit.fruitIndex;
                if (!fruitGroups[index]) {
                    fruitGroups[index] = [];
                }
                fruitGroups[index].push(fruit);
            }
            
            // 각 그룹에서 합이 10이 되는 조합 찾기
            for (const index in fruitGroups) {
                const combinations = findCombinationsWithSum10(fruitGroups[index]);
                
                // 찾은 조합 중에서 접촉 중인 것만 합치기
                for (const combination of combinations) {
                    if (areFruitsInContact(combination)) {
                        mergeFruits(combination);
                        return; // 한 번에 하나의 조합만 합치기
                    }
                }
            }
        }
        
        // 합이 10이 되는 과일 조합 찾기
        function findCombinationsWithSum10(fruits) {
            const result = [];
            
            // 2개 조합 확인
            for (let i = 0; i < fruits.length; i++) {
                for (let j = i + 1; j < fruits.length; j++) {
                    if (fruits[i].fruitNumber + fruits[j].fruitNumber === 10) {
                        result.push([fruits[i], fruits[j]]);
                    }
                }
            }
            
            // 3개 조합 확인
            for (let i = 0; i < fruits.length; i++) {
                for (let j = i + 1; j < fruits.length; j++) {
                    for (let k = j + 1; k < fruits.length; k++) {
                        if (fruits[i].fruitNumber + fruits[j].fruitNumber + fruits[k].fruitNumber === 10) {
                            result.push([fruits[i], fruits[j], fruits[k]]);
                        }
                    }
                }
            }
            
            // 4개 조합 확인
            for (let i = 0; i < fruits.length; i++) {
                for (let j = i + 1; j < fruits.length; j++) {
                    for (let k = j + 1; k < fruits.length; k++) {
                        for (let l = k + 1; l < fruits.length; l++) {
                            if (fruits[i].fruitNumber + fruits[j].fruitNumber + fruits[k].fruitNumber + fruits[l].fruitNumber === 10) {
                                result.push([fruits[i], fruits[j], fruits[k], fruits[l]]);
                            }
                        }
                    }
                }
            }
            
            // 5개 이상의 조합은 재귀 함수로 찾기
            if (fruits.length >= 5) {
                findCombinationsRecursive(fruits, [], 0, 0, result);
            }
            
            return result;
        }
        
        // 재귀적으로 합이 10이 되는 조합 찾기 (5개 이상)
        function findCombinationsRecursive(fruits, currentCombination, currentIndex, currentSum, result) {
            // 현재 합이 10이고 조합의 크기가 5 이상이면 결과에 추가
            if (currentSum === 10 && currentCombination.length >= 5) {
                result.push([...currentCombination]);
                return;
            }
            
            // 합이 10을 초과하거나 모든 과일을 검사했으면 종료
            if (currentSum > 10 || currentIndex >= fruits.length) {
                return;
            }
            
            // 현재 과일을 포함하는 경우
            currentCombination.push(fruits[currentIndex]);
            findCombinationsRecursive(
                fruits,
                currentCombination,
                currentIndex + 1,
                currentSum + fruits[currentIndex].fruitNumber,
                result
            );
            currentCombination.pop();
            
            // 현재 과일을 제외하는 경우
            findCombinationsRecursive(
                fruits,
                currentCombination,
                currentIndex + 1,
                currentSum,
                result
            );
        }
        
        // 과일 라벨 제거 함수 추가
        function removeFruitLabel(body) {
            if (fruitLabels[body.id]) {
                const label = fruitLabels[body.id];
                if (label && label.parentNode) {
                    label.parentNode.removeChild(label);
                }
                delete fruitLabels[body.id];
            }
        }

        // 과일 라벨 생성 함수 추가
        function createFruitLabel(body, number) {
            const label = document.createElement('div');
            label.textContent = number;
            label.style.position = 'absolute';
            label.style.left = `${body.position.x - 15}px`;
            label.style.top = `${body.position.y - 15}px`;
            label.style.color = 'white';
            label.style.fontWeight = 'bold';
            label.style.fontSize = '24px';
            label.style.textAlign = 'center';
            label.style.width = '30px';
            label.style.height = '30px';
            label.style.display = 'flex';
            label.style.justifyContent = 'center';
            label.style.alignItems = 'center';
            label.style.zIndex = 10;
            label.style.pointerEvents = 'none'; // 클릭 이벤트 무시
            
            container.appendChild(label);
            fruitLabels[body.id] = label;
        }

        // 과일 라벨 위치 업데이트 함수 추가
        function updateFruitLabels() {
            for (let i = 0; i < engine.world.bodies.length; i++) {
                const body = engine.world.bodies[i];
                if (body.label === 'fruit' && fruitLabels[body.id]) {
                    const label = fruitLabels[body.id];
                    label.style.left = `${body.position.x - 15}px`;
                    label.style.top = `${body.position.y - 15}px`;
                }
            }
        }

        // 업데이트 함수 추가
        function update() {
            // 화면 밖으로 나간 물체 체크
            for (let i = engine.world.bodies.length - 1; i >= 0; i--) {
                const body = engine.world.bodies[i];
                
                // 과일만 화면 밖으로 나가면 제거
                if (body.label === 'fruit' && !body.isWeight) {
                    if (body.position.y > containerHeight + 100) {
                        removeFruitLabel(body);
                        removeBody(body);
                    }
                }
                
                // 무게추는 화면 밖으로 나가도 유지
                if (body.isWeight && body.position.y > containerHeight + 500) {
                    // 무게추가 너무 아래로 떨어지면 위치 재설정
                    Body.setPosition(body, { x: body.position.x, y: containerHeight - 50 });
                    Body.setVelocity(body, { x: 0, y: 0 });
                }
            }
            
            // 과일 라벨 위치 업데이트
            updateFruitLabels();
            
            // 과일 합치기 검사
            checkFruitMerging();
        }

        // 과일 합치기 함수
        function mergeFruits(combination) {
            if (combination.length < 2) return;
            
            // 모든 과일이 같은 종류인지 확인
            const fruitIndex = combination[0].fruitIndex;
            for (const fruit of combination) {
                if (fruit.fruitIndex !== fruitIndex) return;
            }
            
            // 중간 위치 계산
            let midX = 0, midY = 0;
            for (const fruit of combination) {
                midX += fruit.position.x;
                midY += fruit.position.y;
            }
            midX /= combination.length;
            midY /= combination.length;
            
            // 기존 과일 라벨 제거 및 과일 제거
            for (const fruit of combination) {
                removeFruitLabel(fruit);
                removeBody(fruit);
            }
            
            // 다음 단계 과일 생성
            const newFruitIndex = fruitIndex + 1;
            if (newFruitIndex < FRUITS.length) {
                // 랜덤 숫자 생성 (기존 확률 분포 사용)
                let randomNumber;
                const rand = Math.random();
                
                if (rand < 0.50) { // 50% 확률로 1-3 사이
                    randomNumber = Math.floor(Math.random() * 3) + 1;
                } else if (rand < 0.80) { // 30% 확률로 4-5 사이
                    randomNumber = Math.floor(Math.random() * 2) + 4;
                } else if (rand < 0.95) { // 15% 확률로 6-7 사이
                    randomNumber = Math.floor(Math.random() * 2) + 6;
                } else { // 5% 확률로 8-9 사이
                    randomNumber = Math.floor(Math.random() * 2) + 8;
                }
                
                // 새 과일 생성
                const newFruit = createFruit(midX, midY, newFruitIndex);
                
                // 생성된 과일에 랜덤 숫자 할당
                newFruit.fruitNumber = randomNumber;
                
                // 기존 과일 라벨 제거 후 새로 생성
                removeFruitLabel(newFruit);
                createFruitLabel(newFruit, randomNumber);
                
                // 쿨타임 설정 - 0.5초 동안 합치기 불가능
                newFruit.cooldown = true;
                setTimeout(() => {
                    newFruit.cooldown = false;
                }, 500);
                
                // 기본 점수
                let baseScore = FRUITS[newFruitIndex].score;
                
                // 과일 개수에 따른 보너스 점수 계산 (과일 개수 - 1) * 50% 추가
                let bonusMultiplier = 1 + ((combination.length - 2) * 0.5);
                
                // 최종 점수 계산 (기본 점수 * 보너스 배율)
                let finalScore = Math.floor(baseScore * bonusMultiplier);
                
                // 점수 추가
                score += finalScore;
                document.getElementById('score').textContent = score;
                
                // 로그 남기기
                const fruitName = FRUITS[fruitIndex].name;
                const newFruitName = FRUITS[newFruitIndex].name;
                const numbersText = combination.map(fruit => fruit.fruitNumber).join(' + ');
                const logText = `${fruitName}(${numbersText}) → ${newFruitName}(${randomNumber}) (${finalScore}점, ${combination.length}개 과일 보너스: x${bonusMultiplier.toFixed(1)})`;
                console.log(logText);
            }
        }

        // 바디 제거
        function removeBody(body) {
            World.remove(engine.world, body);
            
            if (body.isFruit) {
                const index = fruits.indexOf(body);
                if (index > -1) {
                    fruits.splice(index, 1);
                }
            } else if (body.isWeight) {
                const index = weights.indexOf(body);
                if (index > -1) {
                    weights.splice(index, 1);
                }
            }
        }

        // 대기 중인 과일 표시
        function updateWaitingFruit() {
            const fruit = FRUITS[nextFruitIndex];
            
            // 1부터 9까지의 랜덤한 숫자 생성 (작은 숫자일수록 확률이 훨씬 높게)
            let randomNumber;
            const rand = Math.random();
            
            if (rand < 0.50) { // 50% 확률로 1-3 사이
                randomNumber = Math.floor(Math.random() * 3) + 1;
            } else if (rand < 0.80) { // 30% 확률로 4-5 사이
                randomNumber = Math.floor(Math.random() * 2) + 4;
            } else if (rand < 0.95) { // 15% 확률로 6-7 사이
                randomNumber = Math.floor(Math.random() * 2) + 6;
            } else { // 5% 확률로 8-9 사이
                randomNumber = Math.floor(Math.random() * 2) + 8;
            }
            
            nextFruitNumber = randomNumber;
            
            waitingFruitElement.style.width = `${fruit.circleRadius * 2}px`;
            waitingFruitElement.style.height = `${fruit.circleRadius * 2}px`;
            waitingFruitElement.style.backgroundColor = fruit.color;
            waitingFruitElement.style.borderRadius = '50%';
            waitingFruitElement.style.display = 'flex';
            waitingFruitElement.style.justifyContent = 'center';
            waitingFruitElement.style.alignItems = 'center';
            waitingFruitElement.style.color = 'white';
            waitingFruitElement.style.fontWeight = 'bold';
            waitingFruitElement.style.fontSize = `${fruit.circleRadius * 0.8}px`;
            waitingFruitElement.textContent = randomNumber;
            waitingFruitElement.style.position = 'absolute';
            waitingFruitElement.style.left = `${mouseX - fruit.circleRadius}px`;
            waitingFruitElement.style.top = '120px';
            
            waitingFruitElement.style.display = canDropFruit ? 'flex' : 'none';
        }

        // 특수 무게추 드롭
        function dropSpecialWeight(x, y) {
            if (!SPECIAL_WEIGHT.available || SPECIAL_WEIGHT.remainingUses <= 0) return;
            
            createSpecialWeight(x, y);
            
            SPECIAL_WEIGHT.remainingUses--;
            specialItemUI.textContent = `무게추 (${SPECIAL_WEIGHT.remainingUses}/${SPECIAL_WEIGHT.maxUses})`;
            
            if (SPECIAL_WEIGHT.remainingUses === 0) {
                specialItemUI.style.opacity = '0.5';
            }
        }

        // 과일 드롭
        function dropFruit() {
            if (!canDropFruit) return;
            
            canDropFruit = false;
            
            const x = mouseX;
            const y = 120;
            
            // 과일 생성
            const fruit = createFruit(x, y, nextFruitIndex);
            
            // 생성된 과일에 대기 중이던 과일의 숫자 할당
            fruit.fruitNumber = nextFruitNumber;
            
            // 다음 과일 준비
            updateNextFruit();
            
            // 일정 시간 후 다시 과일 드롭 가능하도록 설정
            setTimeout(() => {
                canDropFruit = true;
                updateWaitingFruit();
            }, 500);
        }

        // 다음 과일 준비
        function updateNextFruit() {
            nextFruitIndex = 0;
            updateWaitingFruit();
        }

        // 이벤트 리스너 설정
        function setupEventListeners() {
            // 마우스 이동
            container.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                
                if (canDropFruit) {
                    const fruit = FRUITS[nextFruitIndex];
                    waitingFruitElement.style.left = `${mouseX - fruit.circleRadius}px`;
                }
                
                if (isDraggingWeight) {
                    specialItemUI.style.left = `${e.clientX - rect.left - 40}px`;
                    specialItemUI.style.top = `${e.clientY - rect.top - 40}px`;
                }
            });
            
            // 클릭
            container.addEventListener('click', (e) => {
                if (!isDraggingWeight) {
                    dropFruit();
                }
            });
            
            // 무게추 드래그 시작
            let originalWeightPosition = { top: '20px', right: '20px' };
            
            specialItemUI.addEventListener('mousedown', (e) => {
                if (SPECIAL_WEIGHT.available && SPECIAL_WEIGHT.remainingUses > 0) {
                    isDraggingWeight = true;
                    originalWeightPosition = {
                        top: specialItemUI.style.top,
                        right: specialItemUI.style.right
                    };
                    
                    specialItemUI.style.right = 'auto';
                    specialItemUI.style.cursor = 'grabbing';
                    
                    const rect = container.getBoundingClientRect();
                    specialItemUI.style.left = `${e.clientX - rect.left - 40}px`;
                    specialItemUI.style.top = `${e.clientY - rect.top - 40}px`;
                    
                    e.preventDefault();
                }
            });
            
            // 무게추 드래그 종료
            document.addEventListener('mouseup', (e) => {
                if (isDraggingWeight) {
                    isDraggingWeight = false;
                    
                    specialItemUI.style.cursor = 'grab';
                    
                    const rect = container.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if (x >= 0 && x <= containerWidth && y >= 120 && y <= containerHeight) {
                        dropSpecialWeight(x, y);
                        
                        specialItemUI.style.left = 'auto';
                        specialItemUI.style.top = originalWeightPosition.top;
                        specialItemUI.style.right = originalWeightPosition.right;
                    } else {
                        specialItemUI.style.left = 'auto';
                        specialItemUI.style.top = originalWeightPosition.top;
                        specialItemUI.style.right = originalWeightPosition.right;
                    }
                }
            });
            
            // 게임 재시작 버튼
            document.getElementById('restart-button').addEventListener('click', () => {
                resetGame();
            });
        }

        // 게임오버 체크
        function checkGameOver() {
            if (isGameOver) return;
            
            const lineY = 120;
            
            for (let i = 0; i < fruits.length; i++) {
                const fruit = fruits[i];
                
                const isSleeping = fruit.speed < 0.1;
                const isAboveLine = fruit.position.y < lineY;
                
                if (isSleeping && isAboveLine) {
                    gameOver();
                    return;
                }
            }
        }

        // 게임 오버
        function gameOver() {
            isGameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'flex';
            
            Runner.stop(runner);
        }

        // 게임 리셋
        function resetGame() {
            document.getElementById('game-over').style.display = 'none';
            
            score = 0;
            document.getElementById('score').textContent = score;
            isGameOver = false;
            nextFruitIndex = 0;
            canDropFruit = true;
            fruits = [];
            weights = [];
            SPECIAL_WEIGHT.remainingUses = SPECIAL_WEIGHT.maxUses;
            specialItemUI.textContent = `무게추 (${SPECIAL_WEIGHT.remainingUses}/${SPECIAL_WEIGHT.maxUses})`;
            specialItemUI.style.opacity = '1';
            
            if (runner.enabled) {
                Runner.stop(runner);
            }
            
            World.clear(engine.world);
            Engine.clear(engine);
            
            createWalls();
            setupEventListeners();
            setupCollisionEvents();
            updateWaitingFruit();
            
            Runner.run(runner, engine);
        }

        // 게임 초기화
        function initGame() {
            score = 0;
            document.getElementById('score').textContent = score;
            isGameOver = false;
            nextFruitIndex = 0;
            canDropFruit = true;
            fruits = [];
            weights = [];
            SPECIAL_WEIGHT.remainingUses = SPECIAL_WEIGHT.maxUses;
            specialItemUI.textContent = `무게추 (${SPECIAL_WEIGHT.remainingUses}/${SPECIAL_WEIGHT.maxUses})`;
            specialItemUI.style.opacity = '1';
            
            createWalls();
            setupEventListeners();
            setupCollisionEvents();
            updateWaitingFruit();
            
            Runner.run(runner, engine);
            render();
        }

        // 게임 시작
        window.onload = function() {
            initGame();
            
            // 과일 라벨 업데이트 간격 설정
            setInterval(() => {
                updateFruitLabels();
            }, 16); // 약 60fps
            
            // 게임오버 체크 간격 설정
            setInterval(() => {
                checkGameOver();
            }, 1000);
            
            // 업데이트 간격 설정
            setInterval(() => {
                update();
            }, 1000 / 60); // 약 60fps
        };

        // 과일들이 서로 접촉 중인지 확인
        function areFruitsInContact(fruits) {
            if (fruits.length <= 1) return true;
            
            // 모든 과일이 직접 접촉하는지 확인 (그래프 연결 확인)
            const n = fruits.length;
            const connected = Array(n).fill().map(() => Array(n).fill(false));
            
            // 각 과일 쌍에 대해 접촉 여부 확인
            for (let i = 0; i < n; i++) {
                connected[i][i] = true; // 자기 자신과는 연결됨
                
                for (let j = i + 1; j < n; j++) {
                    const dx = fruits[i].position.x - fruits[j].position.x;
                    const dy = fruits[i].position.y - fruits[j].position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const fruitA = FRUITS[fruits[i].fruitIndex];
                    const fruitB = FRUITS[fruits[j].fruitIndex];
                    const minDistance = fruitA.circleRadius + fruitB.circleRadius;
                    
                    // 접촉 여부 확인 (여유 공간 추가)
                    if (distance <= minDistance + 5) {
                        connected[i][j] = connected[j][i] = true;
                    }
                }
            }
            
            // 모든 과일이 하나의 연결된 그룹을 형성하는지 확인 (BFS 사용)
            const visited = Array(n).fill(false);
            const queue = [0]; // 첫 번째 과일부터 시작
            visited[0] = true;
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                for (let i = 0; i < n; i++) {
                    if (connected[current][i] && !visited[i]) {
                        visited[i] = true;
                        queue.push(i);
                    }
                }
            }
            
            // 모든 과일이 방문되었는지 확인
            return visited.every(v => v);
        }

        // 게임 렌더링
        function render() {
            // 캔버스 지우기
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 벽 그리기
            ctx.fillStyle = '#cccccc';
            for (let i = 0; i < walls.length; i++) {
                const wall = walls[i];
                const vertices = wall.vertices;
                
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                
                for (let j = 1; j < vertices.length; j++) {
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
                
                ctx.closePath();
                ctx.fill();
            }
            
            // 과일 그리기
            for (let i = 0; i < engine.world.bodies.length; i++) {
                const body = engine.world.bodies[i];
                if (body.label === 'fruit') {
                    const fruitData = FRUITS[body.fruitIndex];
                    
                    // 과일 원 그리기
                    ctx.beginPath();
                    ctx.arc(body.position.x, body.position.y, fruitData.circleRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = fruitData.color;
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // 참고: 숫자는 HTML 라벨로 표시하므로 여기서는 그리지 않음
                }
            }
            
            // 무게추 그리기
            ctx.fillStyle = SPECIAL_WEIGHT.color;
            for (let i = 0; i < weights.length; i++) {
                const weight = weights[i];
                const vertices = weight.vertices;
                
                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                
                for (let j = 1; j < vertices.length; j++) {
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            requestAnimationFrame(render);
        }
    </script>
</body>
</html>
